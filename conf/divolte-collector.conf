divolte {
	global {
	    server {
	      // The host to which the server binds.
	      // Set to a specific IP address to selectively listen on that interface.
	      host = 0.0.0.0
	      host = ${?DIVOLTE_HOST}

	      // The port on which the sever listens.
	      port = 8290
	      port = ${?DIVOLTE_PORT}

	      // Whether to use the X-Forwarded-For header HTTP header
	      // for determining the source IP of a request if present.
	      // When a X-Forwared-For header is present, the rightmost
	      // IP address of the value is used as source IP when
	      // when multiple IP addresses are separated by a comma.
	      // When the header is present more than once, the last
	      // value will be used.
	      // E.g.
	      // "X-Forwarded-For: 10.200.13.28, 11.45.82.30" ==> 11.45.82.30
	      //
	      // "X-Forwarded-For: 10.200.13.28"
	      // "X-Forwarded-For: 11.45.82.30" ==> 11.45.82.30
	      use_x_forwarded_for = false
	      use_x_forwarded_for = ${?DIVOLTE_USE_XFORWARDED_FOR}

	      // When true Divolte Collector serves a static test page at /.
	      serve_static_resources = true
	      serve_static_resources = ${?DIVOLTE_SERVICE_STATIC_RESOURCES}
	    }
		
		kafka {
		      // Enable Kafka flushing
		      enabled = false

		      // The properties under the producer key in this
		      // configuration are used to create a Properties object
		      // which is passed to Kafka as is. At the very least,
		      // configure the broker list here. For more options
		      // that can be passed to a Kafka producer, see this link:
		      // http://kafka.apache.org/0102/documentation.html#producerconfigs
		      producer = {
		        bootstrap.servers = "10.141.0.81:9092"
		      }
		    }		
	}	
	sinks {
	    // The name of the sink. (It's referred to by the mapping.)
	    kafka {
	      type = kafka

	      // This is the name of the topic that data will be produced on
	      topic = divolte-data
	    }
	  }	
  sources {
    // Once we specify a source, we need to specify all of them.
    // Here's the definition for the browser source we've been using until now.
    browser = {
      type = browser
    }
    // Here's the low-level JSON source we're adding.
    json = {
      type = json
      event_path = /json
    }
  }
  mappings {
    my_mapping = {
      schema_file = "/usr/local/conf/MyEventRecord.avsc"
      mapping_script_file = "/usr/local/conf/mapping.groovy"
      sources = [browser, json]
      sinks = [hdfs]
    }
  }
}